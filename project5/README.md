# Project 5: Extending the SmallC Interpreter

CMSC 330, Fall 2019

Assigned November 21

Due: December 5 at 11:59pm (Late: December 6 at 11:59pm)

P/R/S: 65/0/35

**Before You Begin**
-----------------------

***PLEASE READ THIS SECTION!***

In Projects 4a and 4b, you were able to implement your parser in either a functional or imperative manner. At the bottom of `parser.ml`, please uncomment the correct line that corresponds with your implementation. ***You will fail all tests if you do not do this.*** You can then copy in your lexer and parser implementation from the previous portion of the project.


## Ground Rules and Extra Info

You must work on this project alone as with most other CS projects. See the Academic Integrity section for more information.

In your code, you may use **any** non-imperative standard library functions (with the exception of printing), but the ones that will be useful to you will be found in the [`Pervasives` module][pervasives doc] and the [`List` module][list doc]. Note that the `List` module has been disallowed in previous projects, but in the case of this project and projects going forward it will be allowed.

You may use imperative structures of OCaml, such as references. If you used the imperative implementation for your parser, that is fine. You **may not** use imperative modules, like the `Hashtbl` module.

## Compilation, Tests, and Running

You can run the SmallC interpreter directly on a SmallC program by running `dune exec bin/evalc.bc -- <filename>` or use the local script `./evalc <filename>`. This driver, provided by us, reads in a program from a file and evaluates the code, outputing the results of any print statements present in the source file. Think of this command a lot like the `ruby` command, but instead of running the ruby interpreter, it runs the SmallC interpreter that you wrote yourself! In order to use this, you must copy over your lexer and parser from P4A.

If you would like more detailed information about what your code produced, running `dune exec bin/evalc.bc -- <filename> -R` provides a report on the resultant variable bindings as reported by your evaluator. The `evalc` script adds this argument by default, `./evalc <filename>`. If you would like to see the data structure that is being generated by the parser and being fed into your interpreter, run `dune exec bin/evalc.bc -- <filename> -U` and our `Utils` module will translate the data structure into a string and print it out for you - this part does not require any of your code, so feel free to try it on the public tests before you even start! Using these tools can give you an advantage when testing; that's why we're providing it! Note that you don't need to touch `bin/evalc.ml` yourself, as it only functions as an entry point for the interpreter and is independent of your implementation.

## Introduction

Your previous interpreter was missing a key feature of `C`: _functions_. Previously the main function was declared in the source code, which then was ran in a local environment. To add functions we need to add a new function declaration statement and a new function call expression. The new semantics are in the new updated in `semantics.pdf`.

## Functions

The previous SmallC Interpreter only contained the main function, however, real programs are more complex than this.
Previously the main function was declared in the source code, which then was ran in a local environment. To add functions we need to add a new function declaration statement and a new function call expression. To see how these are represented, take a look at `smallCTypes.ml`
You'll see that we've added a new type of expression, `FunctionCall of string * expr list`, to capture the idea of calling a function with some name (i.e. the string) and some arguments (i.e. the list of expressions). We've also added a new type of statement, `FunctionDecl of string * data_type * parameter list * stmt` to capture declaring a function with some name (string), some return type (captured by the data_type), a list of parameters (parameter list), and a body (stmt).

In order to add this functionality, we need new tokens. Take a look at `tokentypes.ml`. You'll see that we've added two new tokens, `Tok_Comma` and `Tok_Return`. You can convince yourself why adding these tokens captures the essence of adding functions in SmallC (the comma for having a multi-argument function, and return to be able to return a value out of a function).

Additionally, identifiers can now contain underscores.

In this project, you will be able to tokenize, parse, and evaluate the following (valid) SmallC program:
```c
int foo(int a, int b) {
  int c;
  c = a + b;
  return a;
}

int factorial(int n) {
  if(n == 1) {
    return n;
  }
  else {
    return n * factorial(n-(1));
  }
}

int main() {
  int a;
  int b;
  int c;
  int d;
  a = 1;
  b = 2;
  c = 4;
  d = foo(a, b) + factorial(c);
}
```

*The formal semantics rule for Function Call in semantics.pdf may be helpful!*

## Lazy Evaluation and Thunks

In lecture, we introduced the concept of a lazy evaluation or "call-by-name", which is where arguments to a function are only evaluated if they are used by the function. While C is call-by-value, there are some advantages to call-by-name evaluation. For instance, if one of the arguments requires us to go into an infinite recursion, not evaluating it unless absolutely necessary is a pretty good strategy.
Despite these advantages, a practical drawback of lazy evaluation is that it allows for a lot of crazy things to happen. What if a parameter is supposed to be of type `int`, but we pass in type `bool`? What if I pass in something like `x - y + z + 2` where `x`, `y`, and `z` are local variables in my current environment? Since we don't greedily evaluate all of our parameters beforehand, we open ourselves to some vulnerabilities.

To fix these issues with lazy evaluation we use **Thunks**, a method to combine an expression, the environment it should be evaluated in, and the expected type into a single  value. We define: `Thunk of environment * expr * data_type`. When evaluating a function call each expression is wrapped in a thunk with the **callers** environment and the type the **callee's** corresponding parameter expects. By maintaining an environment, we can now evaluate expressions _across_ different environments, and by maintaining an expected type, we can catch instances where the types do not match.

After implementing lazy evaluation, your program should be able to execute the following (valid) SmallC program with no errors!
```c
int infinite_loop(int a) {
  while(true) {
    a = a + 1;
  }
  return a;
}

int normal_function(int unecessary_argument) {
  return 3;
}

int main() {
  int a;
  int b;
  a = 3;
  b = normal_function(infinite_loop(a));
}
```
Here, the code will not evaluate the infinite loop argument of the function `normal_function` and as a result, will execute normally and not cause a StackOverflow error.

### Part 1: Lexing and Parsing

In order to extend the lexer, add support for the tokens mentioned `Functions` section, `Tok_Comma` and `Tok_Return`. Additionally, ensure your `Tok_ID` allows for underscores in identifiers, as mentioned above.
In order to extend the parser, refer to this updated CFG that includes support for function calls and function declarations.

#### Expressions

- Expr -> OrExpr
- OrExpr -> AndExpr `||` OrExpr | AndExpr
- AndExpr -> EqualityExpr `&&` AndExpr | EqualityExpr
- EqualityExpr -> RelationalExpr EqualityOperator EqualityExpr | RelationalExpr
    - EqualityOperator -> `==` | `!=`
- RelationalExpr -> AdditiveExpr RelationalOperator RelationalExpr | AdditiveExpr
    - RelationalOperator -> `<` | `>` | `<=` | `>=`
- AdditiveExpr -> MultiplicativeExpr AdditiveOperator AdditiveExpr | MultiplicativeExpr
    - AdditiveOperator -> `+` | `-`
- MultiplicativeExpr -> PowerExpr MultiplicativeOperator MultiplicativeExpr | PowerExpr
    - MultiplicativeOperator -> `*` | `/`
- PowerExpr -> UnaryExpr `^` PowerExpr | UnaryExpr
- UnaryExpr -> `!` UnaryExpr | PrimaryExpr
- PrimaryExpr -> *`Tok_Int`* | *`Tok_Bool`* | *`Tok_ID`* | `(` Expr `)` | **FunctionCall**
- **FunctionCall** -> _`Tok_ID`_ `(` `)` | _`Tok_ID`_ `(` Expr ExprList `)`
    - ExprList -> `,` Expr ExprList | ε

In this modified grammar for expressions, notice that you will have to parse function calls whenever you parse a primary expression. The derivation rule for FunctionCall may be slightly tricky, but the idea is any function call will involve a `Tok_ID`, namely the name of the function that is being called, followed by any number of comma-separated expressions surrounded in parentheses. Be careful with how you parse parentheses here, since each argument passed into a function can have commas of its own, as in the following example:
```c
x = foo((2+2*3), (9+4), (1 == 2))
```


#### Statements

- Stmt -> StmtOptions Stmt | StmtOptions
  - StmtOptions -> DeclareStmt | AssignStmt | PrintStmt | IfStmt | ForStmt | WhileStmt | ReturnStmt
    - DeclareStmt -> BasicType ID `;`
      - BasicType -> `int` | `bool`
    - AssignStmt -> ID `=` Expr `;`
    - PrintStmt -> `printf` `(` Expr `)` `;`
    - IfStmt -> `if` `(` Expr `)` `{` Stmt `}` ElseBranch
      - ElseBranch -> `else` `{` Stmt `}` | ε
    - ForStmt -> `for` `(` ID `from` Expr `to` Expr `)` `{` Stmt `}`
    - WhileStmt -> `while` `(` Expr `)` `{` Stmt `}`
    - ReturnStmt -> `return` Expr `;`
- TopLevel -> **FunctionDecl** TopLevel | ε
  - **FunctionDecl** -> BasicType ID `(` `)` `{` Stmt `}` | BasicType ID `(` Param Params `)` `{` Stmt `}` | `int` `main` `(` `)` `{` Stmt `}`
    - Params -> `,` Param Params | ε
    - Param -> BasicType ID

In this modified grammar for statements, there is a new rule `TopLevel`. This rule is meant to capture the idea of function declarations, and all of the processing for it will happen within the function `parse_top_level` found in `parser.ml`. In TopLevel, we can have any number of functions sequenced together, where each function consists of a return type (`BasicType`, e.g. `int`), a name (`ID`, e.g. `foo`), any number of parameters (where a parameter is a tuple containing the name of the argument and its datatype, e.g. int a => ("a", Int_Type)), followed by the body of the function (`Stmt`).     
You might notice that there is no `top-level` *type* in `smallCTypes.ml` the way there is a `stmt` type. This is because function declarations are being treated like statements. Since a function declaration is defined as a statement, this grammar will *technically* accept nested functions. However, this would complicate the semantics so we won't test for this. In code, unlike `parse_main` in the previous assignments, there is now a function `parse_top_level`, which will parse all function declarations (including main), and a function `parse_stmt`, which won't expect any function declarations and is similar to the `parse_stmt` you implemented in Project 4a/b. Therefore, the only change necessary to `parse_stmt` is parsing return statements. **Besides for return statements, all new parsing for statements in this project will happen in `parse_top_level`.**

### A Formal Example of Parsing
Take this SmallC example:
```c
int add(int a, int b) {
  return a + b;
}
int main() {
  return add(1, 2);
}
```

This code will output the following AST after being called with parse_top_level: You don't have to sift through it unless you're testing. Basically, the key things to notice here are:
- The entire program is a sequence of two function declarations, `add`, and `main`. Each of these function declarations holds a name, a return type, a list of all the arguments (names + return types), and finally, statement output that you're used to from Project 4a. *The entire body of a function is abstracted away in the fourth member of the tuple in FunctionDecl*.
- The main function is also a function declaration. **In all of our programs, the main function will come last**.
- With the exception of `main`, **every function will have a non-void return type and a corresponding return statement.**

```caml
Seq
 (FunctionDecl ("add", Int_Type,
   [("a", Int_Type); ("b", Int_Type)],
   Seq
    (Return
      (Add (ID "a", ID "b")),
    NoOp)),
 FunctionDecl ("main", Int_Type, [],
  Seq
   (Return
     (FunctionCall ("add",
       [Int 1; Int 2])),
   NoOp)))
```

### Part 2: `eval_expr`

`eval_expr` takes an environment `env` and an expression `e` and produces the result of _evaluating_ `e`, which is something of type `value` (`Int_Val` or `Bool_Val`). However, now we also have a global function definition environment, which doesn't need to be passed and is visible to all expressions after the functions have all been declared.

#### Function Call

When calling a function first the function is looked up in the function environment, and we return an error (any exception, specifically Exception: Not_Found, is fine) if the function hasn't been defined before. Then, each argument expressions become thunks and are stored in a new environment where the parameter names bind to each corresponding expression. If there are too many or not enough arguments provided, raise a `DeclareError`. Then the statement that is the body of the function is evaluated under the new environment. When the function returns it adds a new element in its environment called "~ret" (note the ~ in because it is not a valid Identifier and thus won't clash with any in the source code). The environment is then returned and `~ret` can be looked up to find the final value. If the type returned does not match the function signature, raise a `TypeError`.

#### ID

Since thunks become bound to IDs they are evaluated when the ID is evaluated. The thunk is evaluated by using the stored environment to call `eval_expr` and the returned value must be type checked with the type of the thunk. In fancy languages like Haskell, the expression in the thunk would only be evaluated once, however, for simplicity it is run every time the thunk value is needed.

### Part 3: `eval_stmt`

Evaluating function declarations adds the function to the global function environment and in the case of main (which is assumed to be the last function), the body of the function is evaluated.

Additionally, please note that for loops for this project's updated SmallC can have variables that are previously undeclared. Consider this example of a valid SmallC program:
```c
int main(){
  for (x from 1 to 10){
    printf(x);
  }  
}
```

### Helper Functions in `eval.ml`
We have designed several helper functions to ease the evaluation process. As in Project 3, none of these helper functions are strictly required. The tests will simply check to ensure the environment you return after evaluation is identical to the one we return after evaluation. Thus, although we encourage you to use the following helper functions to aid your implementation, they are by no means required.
There are descriptive blurbs above **every** helper function in `eval.ml`, so make sure you read them! If you decide not to use our helpers, still read the blurbs so you can ensure your implementation has the functionality we expect. Many of the helper functions (such as `insert_val` and `get_val`) are functions you probably used in some form for P4b, and others like `check_type` are trivial to implement. We will expand on two non-trivial helper functions below:

`add_func` and `get_func`
As stated earlier, in order to evaluate the result of calling a function `foo()`, we store the function's information (name, return type, parameters, and body) inside a globally accessible funs reference that you can access. `add_func` adds to this global function list, raising a `DeclareError` if the function already exists (since function overloading is not allowed in C). `get_func` should search through the functions and retrieve the entry associated with the function name.

`new_func_scope`
 New_func_scope is the main engine by which lazy evaluation happens during function calls. `new_func_scope` takes a list of parameters, arguments, and the current environment, and transforms each argument into a thunk (remind yourself that a thunk holds the caller's environment, the expression, and its expected return type), inserts each thunk into the environment, and returns the final environment. **Hint:** This function is a good place to raise a `DeclareError` if there are too many or not enough arguments.

### Debugging Help

In `builtins.ml` contains builtin functions that can be used to print out expressions and the current environment. Check out `tests/data/public_inputs/builtins.c` for an example of how to use them. You'll notice that since there isn't a function call statment the functions still need to be in expressions.

## Project Submission

You should submit the file `eval.ml` containing your solution. You may submit other files, but they will be ignored during grading. We will run your solution as individual OUnit tests just as in the provided public test file.

Be sure to follow the project description exactly! Your solution will be graded automatically, so any deviation from the specification will result in lost points.

You can submit your project by doing the following:

- Submit directly by executing a the submission script on a computer with Java and network access. Included in this project are the submission scripts and related files listed under **Project Files**. These files should be in the directory containing your project. From there you can either execute submit.rb or run the command `java -jar submit.jar` directly (this is all submit.rb does).

Make sure that your submission is received by checking the [submit server][submit server] after submitting.

## Academic Integrity

Please **carefully read** the academic honesty section of the course syllabus. **Any evidence** of impermissible cooperation on projects, use of disallowed materials or resources, or unauthorized use of computer accounts, **will be** submitted to the Student Honor Council, which could result in an XF for the course, or suspension or expulsion from the University. Be sure you understand what you are and what you are not permitted to do in regards to academic integrity when it comes to project assignments. These policies apply to all students, and the Student Honor Council does not consider lack of knowledge of the policies to be a defense for violating them. Full information is found in the course syllabus, which you should review before starting.

<!-- Link References -->
[list doc]: https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html
[hack github]: https://github.com/facebook/hhvm/tree/master/hphp/hack
[semantics document]: semantics.pdf

<!-- These should always be left alone or at most updated -->
[pervasives doc]: https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html
[git instructions]: ../git_cheatsheet.md
[submit server]: submit.cs.umd.edu
